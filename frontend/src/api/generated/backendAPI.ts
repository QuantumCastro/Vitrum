/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Backend API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from '../http-client';
import type { ErrorType } from '../http-client';
export type RootHealthHealthGet200 = {[key: string]: string};

export interface VaultWithNotes {
  created_at: string;
  id: string;
  name: string;
  notes?: NoteRead[];
  theme: string;
  updated_at: string;
}

export type VaultUpdateTheme = string | null;

export type VaultUpdateName = string | null;

export interface VaultUpdate {
  name?: VaultUpdateName;
  theme?: VaultUpdateTheme;
}

export type VaultCreateTheme = string | null;

export interface VaultCreate {
  name: string;
  theme?: VaultCreateTheme;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type UserReadDisplayName = string | null;

export interface UserRead {
  created_at: string;
  display_name?: UserReadDisplayName;
  email: string;
  id: string;
  updated_at: string;
}

export interface TokenResponse {
  access_token: string;
  token_type?: string;
  user: UserRead;
}

export type RegisterRequestDisplayName = string | null;

export interface RegisterRequest {
  display_name?: RegisterRequestDisplayName;
  email: string;
  password: string;
}

export type NoteUpdateTitle = string | null;

export type NoteUpdateLinks = string[] | null;

export type NoteUpdateContent = string | null;

export interface NoteUpdate {
  content?: NoteUpdateContent;
  links?: NoteUpdateLinks;
  title?: NoteUpdateTitle;
}

export interface NoteRead {
  content?: string;
  created_at: string;
  id: string;
  links?: string[];
  title?: string;
  updated_at: string;
  vault_id: string;
}

export interface NoteCreate {
  content?: string;
  links?: string[];
  title?: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}




type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * @summary Root Health
 */
export const rootHealthHealthGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RootHealthHealthGet200>(
      {url: `/health`, method: 'GET', signal
    },
      options);
    }
  

export const getRootHealthHealthGetQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getRootHealthHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof rootHealthHealthGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootHealthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootHealthHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootHealthHealthGet>>> = ({ signal }) => rootHealthHealthGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootHealthHealthGet>>, TError, TData> & { queryKey: QueryKey }
}

export type RootHealthHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootHealthHealthGet>>>
export type RootHealthHealthGetQueryError = ErrorType<unknown>

/**
 * @summary Root Health
 */
export const useRootHealthHealthGet = <TData = Awaited<ReturnType<typeof rootHealthHealthGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootHealthHealthGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRootHealthHealthGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Register
 */
export const registerApiAuthRegisterPost = (
    registerRequest: RegisterRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<TokenResponse>(
      {url: `/api/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerRequest
    },
      options);
    }
  


export const getRegisterApiAuthRegisterPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, TError,{data: RegisterRequest}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  registerApiAuthRegisterPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterApiAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>>
    export type RegisterApiAuthRegisterPostMutationBody = RegisterRequest
    export type RegisterApiAuthRegisterPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Register
 */
export const useRegisterApiAuthRegisterPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiAuthRegisterPost>>, TError,{data: RegisterRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof registerApiAuthRegisterPost>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterApiAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Login
 */
export const loginApiAuthLoginPost = (
    loginRequest: LoginRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<TokenResponse>(
      {url: `/api/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest
    },
      options);
    }
  


export const getLoginApiAuthLoginPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: LoginRequest}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  loginApiAuthLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginApiAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiAuthLoginPost>>>
    export type LoginApiAuthLoginPostMutationBody = LoginRequest
    export type LoginApiAuthLoginPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Login
 */
export const useLoginApiAuthLoginPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiAuthLoginPost>>, TError,{data: LoginRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof loginApiAuthLoginPost>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginApiAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Me
 */
export const readMeApiAuthMeGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead>(
      {url: `/api/auth/me`, method: 'GET', signal
    },
      options);
    }
  

export const getReadMeApiAuthMeGetQueryKey = () => {
    return [`/api/auth/me`] as const;
    }

    
export const getReadMeApiAuthMeGetQueryOptions = <TData = Awaited<ReturnType<typeof readMeApiAuthMeGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readMeApiAuthMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadMeApiAuthMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readMeApiAuthMeGet>>> = ({ signal }) => readMeApiAuthMeGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readMeApiAuthMeGet>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadMeApiAuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof readMeApiAuthMeGet>>>
export type ReadMeApiAuthMeGetQueryError = ErrorType<unknown>

/**
 * @summary Read Me
 */
export const useReadMeApiAuthMeGet = <TData = Awaited<ReturnType<typeof readMeApiAuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readMeApiAuthMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadMeApiAuthMeGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Vaults
 */
export const listVaultsApiVaultsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<VaultWithNotes[]>(
      {url: `/api/vaults`, method: 'GET', signal
    },
      options);
    }
  

export const getListVaultsApiVaultsGetQueryKey = () => {
    return [`/api/vaults`] as const;
    }

    
export const getListVaultsApiVaultsGetQueryOptions = <TData = Awaited<ReturnType<typeof listVaultsApiVaultsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVaultsApiVaultsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListVaultsApiVaultsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listVaultsApiVaultsGet>>> = ({ signal }) => listVaultsApiVaultsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listVaultsApiVaultsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type ListVaultsApiVaultsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listVaultsApiVaultsGet>>>
export type ListVaultsApiVaultsGetQueryError = ErrorType<unknown>

/**
 * @summary List Vaults
 */
export const useListVaultsApiVaultsGet = <TData = Awaited<ReturnType<typeof listVaultsApiVaultsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listVaultsApiVaultsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListVaultsApiVaultsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Vault
 */
export const createVaultApiVaultsPost = (
    vaultCreate: VaultCreate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<VaultWithNotes>(
      {url: `/api/vaults`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: vaultCreate
    },
      options);
    }
  


export const getCreateVaultApiVaultsPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVaultApiVaultsPost>>, TError,{data: VaultCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createVaultApiVaultsPost>>, TError,{data: VaultCreate}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createVaultApiVaultsPost>>, {data: VaultCreate}> = (props) => {
          const {data} = props ?? {};

          return  createVaultApiVaultsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateVaultApiVaultsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createVaultApiVaultsPost>>>
    export type CreateVaultApiVaultsPostMutationBody = VaultCreate
    export type CreateVaultApiVaultsPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create Vault
 */
export const useCreateVaultApiVaultsPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVaultApiVaultsPost>>, TError,{data: VaultCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createVaultApiVaultsPost>>,
        TError,
        {data: VaultCreate},
        TContext
      > => {

      const mutationOptions = getCreateVaultApiVaultsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Vault
 */
export const readVaultApiVaultsVaultIdGet = (
    vaultId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<VaultWithNotes>(
      {url: `/api/vaults/${vaultId}`, method: 'GET', signal
    },
      options);
    }
  

export const getReadVaultApiVaultsVaultIdGetQueryKey = (vaultId: string,) => {
    return [`/api/vaults/${vaultId}`] as const;
    }

    
export const getReadVaultApiVaultsVaultIdGetQueryOptions = <TData = Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>, TError = ErrorType<HTTPValidationError>>(vaultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadVaultApiVaultsVaultIdGetQueryKey(vaultId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>> = ({ signal }) => readVaultApiVaultsVaultIdGet(vaultId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(vaultId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadVaultApiVaultsVaultIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>>
export type ReadVaultApiVaultsVaultIdGetQueryError = ErrorType<HTTPValidationError>

/**
 * @summary Read Vault
 */
export const useReadVaultApiVaultsVaultIdGet = <TData = Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>, TError = ErrorType<HTTPValidationError>>(
 vaultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readVaultApiVaultsVaultIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadVaultApiVaultsVaultIdGetQueryOptions(vaultId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Vault
 */
export const updateVaultApiVaultsVaultIdPatch = (
    vaultId: string,
    vaultUpdate: VaultUpdate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<VaultWithNotes>(
      {url: `/api/vaults/${vaultId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: vaultUpdate
    },
      options);
    }
  


export const getUpdateVaultApiVaultsVaultIdPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateVaultApiVaultsVaultIdPatch>>, TError,{vaultId: string;data: VaultUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateVaultApiVaultsVaultIdPatch>>, TError,{vaultId: string;data: VaultUpdate}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateVaultApiVaultsVaultIdPatch>>, {vaultId: string;data: VaultUpdate}> = (props) => {
          const {vaultId,data} = props ?? {};

          return  updateVaultApiVaultsVaultIdPatch(vaultId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateVaultApiVaultsVaultIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateVaultApiVaultsVaultIdPatch>>>
    export type UpdateVaultApiVaultsVaultIdPatchMutationBody = VaultUpdate
    export type UpdateVaultApiVaultsVaultIdPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Vault
 */
export const useUpdateVaultApiVaultsVaultIdPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateVaultApiVaultsVaultIdPatch>>, TError,{vaultId: string;data: VaultUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateVaultApiVaultsVaultIdPatch>>,
        TError,
        {vaultId: string;data: VaultUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateVaultApiVaultsVaultIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List Notes
 */
export const listNotesApiVaultsVaultIdNotesGet = (
    vaultId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<NoteRead[]>(
      {url: `/api/vaults/${vaultId}/notes`, method: 'GET', signal
    },
      options);
    }
  

export const getListNotesApiVaultsVaultIdNotesGetQueryKey = (vaultId: string,) => {
    return [`/api/vaults/${vaultId}/notes`] as const;
    }

    
export const getListNotesApiVaultsVaultIdNotesGetQueryOptions = <TData = Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>, TError = ErrorType<HTTPValidationError>>(vaultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNotesApiVaultsVaultIdNotesGetQueryKey(vaultId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>> = ({ signal }) => listNotesApiVaultsVaultIdNotesGet(vaultId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(vaultId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type ListNotesApiVaultsVaultIdNotesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>>
export type ListNotesApiVaultsVaultIdNotesGetQueryError = ErrorType<HTTPValidationError>

/**
 * @summary List Notes
 */
export const useListNotesApiVaultsVaultIdNotesGet = <TData = Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>, TError = ErrorType<HTTPValidationError>>(
 vaultId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNotesApiVaultsVaultIdNotesGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getListNotesApiVaultsVaultIdNotesGetQueryOptions(vaultId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Note
 */
export const createNoteApiVaultsVaultIdNotesPost = (
    vaultId: string,
    noteCreate: NoteCreate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NoteRead>(
      {url: `/api/vaults/${vaultId}/notes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: noteCreate
    },
      options);
    }
  


export const getCreateNoteApiVaultsVaultIdNotesPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNoteApiVaultsVaultIdNotesPost>>, TError,{vaultId: string;data: NoteCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createNoteApiVaultsVaultIdNotesPost>>, TError,{vaultId: string;data: NoteCreate}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createNoteApiVaultsVaultIdNotesPost>>, {vaultId: string;data: NoteCreate}> = (props) => {
          const {vaultId,data} = props ?? {};

          return  createNoteApiVaultsVaultIdNotesPost(vaultId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateNoteApiVaultsVaultIdNotesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createNoteApiVaultsVaultIdNotesPost>>>
    export type CreateNoteApiVaultsVaultIdNotesPostMutationBody = NoteCreate
    export type CreateNoteApiVaultsVaultIdNotesPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create Note
 */
export const useCreateNoteApiVaultsVaultIdNotesPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createNoteApiVaultsVaultIdNotesPost>>, TError,{vaultId: string;data: NoteCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createNoteApiVaultsVaultIdNotesPost>>,
        TError,
        {vaultId: string;data: NoteCreate},
        TContext
      > => {

      const mutationOptions = getCreateNoteApiVaultsVaultIdNotesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Update Note
 */
export const updateNoteApiVaultsVaultIdNotesNoteIdPatch = (
    vaultId: string,
    noteId: string,
    noteUpdate: NoteUpdate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<NoteRead>(
      {url: `/api/vaults/${vaultId}/notes/${noteId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: noteUpdate
    },
      options);
    }
  


export const getUpdateNoteApiVaultsVaultIdNotesNoteIdPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNoteApiVaultsVaultIdNotesNoteIdPatch>>, TError,{vaultId: string;noteId: string;data: NoteUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateNoteApiVaultsVaultIdNotesNoteIdPatch>>, TError,{vaultId: string;noteId: string;data: NoteUpdate}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateNoteApiVaultsVaultIdNotesNoteIdPatch>>, {vaultId: string;noteId: string;data: NoteUpdate}> = (props) => {
          const {vaultId,noteId,data} = props ?? {};

          return  updateNoteApiVaultsVaultIdNotesNoteIdPatch(vaultId,noteId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateNoteApiVaultsVaultIdNotesNoteIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateNoteApiVaultsVaultIdNotesNoteIdPatch>>>
    export type UpdateNoteApiVaultsVaultIdNotesNoteIdPatchMutationBody = NoteUpdate
    export type UpdateNoteApiVaultsVaultIdNotesNoteIdPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Note
 */
export const useUpdateNoteApiVaultsVaultIdNotesNoteIdPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateNoteApiVaultsVaultIdNotesNoteIdPatch>>, TError,{vaultId: string;noteId: string;data: NoteUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateNoteApiVaultsVaultIdNotesNoteIdPatch>>,
        TError,
        {vaultId: string;noteId: string;data: NoteUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateNoteApiVaultsVaultIdNotesNoteIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Note
 */
export const deleteNoteApiVaultsVaultIdNotesNoteIdDelete = (
    vaultId: string,
    noteId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/vaults/${vaultId}/notes/${noteId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteNoteApiVaultsVaultIdNotesNoteIdDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNoteApiVaultsVaultIdNotesNoteIdDelete>>, TError,{vaultId: string;noteId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteNoteApiVaultsVaultIdNotesNoteIdDelete>>, TError,{vaultId: string;noteId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteNoteApiVaultsVaultIdNotesNoteIdDelete>>, {vaultId: string;noteId: string}> = (props) => {
          const {vaultId,noteId} = props ?? {};

          return  deleteNoteApiVaultsVaultIdNotesNoteIdDelete(vaultId,noteId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteNoteApiVaultsVaultIdNotesNoteIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteNoteApiVaultsVaultIdNotesNoteIdDelete>>>
    
    export type DeleteNoteApiVaultsVaultIdNotesNoteIdDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete Note
 */
export const useDeleteNoteApiVaultsVaultIdNotesNoteIdDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteNoteApiVaultsVaultIdNotesNoteIdDelete>>, TError,{vaultId: string;noteId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteNoteApiVaultsVaultIdNotesNoteIdDelete>>,
        TError,
        {vaultId: string;noteId: string},
        TContext
      > => {

      const mutationOptions = getDeleteNoteApiVaultsVaultIdNotesNoteIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
